namespace ca.mcgill.ecse223.tileo.model;

use TileOPersistence.ump;
use TileOControllerStates.ump;

class TileO {
  1 <@>- * Game games;
  1 -> 0..1 Game currentGame;
  
  public NormalTile addNormalTile(int x, int y, Game game){

    return new NormalTile(x, y, game);
  }

  public ActionTile addActionTile(int x, int y, Game game, int inactivtyPeriod){

    return new ActionTile(x, y, game, inactivtyPeriod);
  }

  public WinTile addWinTile(int x, int y, Game game){

    return new WinTile(x, y, game);
  }

  public boolean removeTile(Tile tile){

    boolean wasRemoved = false;

    //if(!this.equals(tile.getTileO))
    tile.delete();
    wasRemoved = true;

    return wasRemoved;
  }
}

class Game {
  mode { DESIGN{} GAME{} GAME_WON{} GAME_ROLLDIEACTIONCARD{} GAME_CONNECTTILESACTIONCARD{} GAME_REMOVECONNECTIONACTIONCARD{} GAME_TELEPORTACTIONCARD{} GAME_LOSETURNACTIONCARD{} }
  1 <@>- 2..4 Player players;
  1 <@>- * Tile tiles;
  1 <@>- * Connection connections;
  1 <@>- 1 Deck deck;
  1 <@>- 1 Die die;
  1 -> 0..1 Player currentPlayer;
  1 -> 0..1 WinTile winTile;
  1 -> * ActionTile inactiveActionTiles;
  const Integer SpareConnectionPieces = 32;
  Integer currentConnectionPieces;
  const Integer NumberOfActionCards = 32;
  lazy filename;
  public  String dieNumber;
  
  
  public int getMaxSize() {
	  int max=0;
	  for (Tile aTile: tiles){
		  if (aTile.getX()>max)
			  max = aTile.getX();
		  if (aTile.getY()>max)
			  max = aTile.getY();
	  }
	  return max+1; // index starts at 0
  }
  
  public boolean connectTiles(Tile t1, Tile t2) {
	boolean wasAdded = false;
	int dx = t1.getX() - t2.getX();
  	int dy = t1.getY() - t2.getY();
  	
  	if (((dx==0&&(dy==1||dy==-1))||(dy==0&&(dx==1||dx==-1))) && t1!=t2 && t1!=null && t2!=null) {
  		Connection conn = new Connection(this);
  		conn.addTile(t1);
  		conn.addTile(t2);
  		wasAdded = true;
  	}
  	return wasAdded;
  }
  
  public boolean disconnectTiles(Tile t1, Tile t2) {
	Connection conn = null;
	boolean wasDeleted = false;
  	int dx = t1.getX() - t2.getX();
  	int dy = t1.getY() - t2.getY();
  	
  	if (((dx==0&&(dy==1||dy==-1))||(dy==0&&(dx==1||dx==-1))) && t1!=t2 && t1!=null && t2!=null) {
  		for (Connection c: t1.getConnections()){
  			if (t2 == c.getTile(0) || t2 == c.getTile(1)){
  				conn = c;
  				break;
  			}
  		}
  	}   	
  	if (conn!=null){
  		conn.delete();
  		wasDeleted = true;
  	}
  	return wasDeleted;
  }
  
  public ArrayList<Tile> rollDie() {
	int n = getDie().roll();
	dieNumber = Integer.toString(n);
  	System.out.println("Die: "+n);
  	ArrayList<Tile> possibleTiles = getCurrentPlayer().getPossibleMoves(n);
  	return possibleTiles;
  }
  
  public void setNextPlayer() {
  	while (true) {
  	  setCurrentPlayer(getPlayer((indexOfPlayer(getCurrentPlayer()) + 1)%numberOfPlayers()));
  	  if (getCurrentPlayer().getPlayerState()==Player.PlayerState.SkipTurn){
  	  	getCurrentPlayer().turnSkipped();
  	  }
  	  else break;
  	}
  	for (int i=0; i<inactiveActionTiles.size(); ++i) {
  		ActionTile t = inactiveActionTiles.get(i);
  		t.setTurnsUntilActive(t.getTurnsUntilActive()-1);
  		if (t.getTurnsUntilActive()==0) {
  			removeInactiveActionTile(t);
  			t.inactivityPeriodCompleted();
  			i--;
  		}
  	}
  }
  
  public void setNextCard() {
  	Deck currentDeck = getDeck();
  	ActionCard currentCard = currentDeck.getCurrentCard();
  	if (currentDeck.indexOfCard(currentCard)==currentDeck.numberOfCards()-1){
        currentDeck.shuffle();
        currentDeck.setCurrentCard(currentDeck.getCard(0));
    }
    else{
    	currentDeck.setCurrentCard(currentDeck.getCard(currentDeck.indexOfCard(currentCard)+1));
    }
  }
}

class Player {
  depend ca.mcgill.ecse223.tileo.util.Node;
	
  color { RED{} BLUE{} GREEN{} YELLOW{} }
  1 -> 0..1 Tile startingTile;
  0..4 -> 0..1 Tile currentTile;
  unique Integer number;
  Integer turnsUntilActive = 0;
  
  PlayerState {
  	Play {
  	  loseTurn -> SkipTurn;
  	}
  	SkipTurn {
  	  turnSkipped -> Play;
  	}
  }
  
  
  public ArrayList<Tile> getPossibleMoves(int depth){
      // Depth first search with limited depth, Iterate over the possible children
      // Cannot go back but loops are allowed
      Stack<Node> fringe = new Stack<Node>();
      List<Connection> connections;
      List<Tile> connectedTiles;
      HashSet<Tile> possibleTiles = new HashSet<Tile>();
      int tIdx;
      Tile t;
      
      Node current = new Node(currentTile, null, 0);
      fringe.push(current);

      while (!fringe.isEmpty()) {
          current = fringe.pop();
    	  t = current.getTile();
    	  
          if (current.getDepth() == depth){
        	  possibleTiles.add(t);
              continue;
          }
          
          connections = t.getConnections();
          for (Connection aConnection : connections){
        	  connectedTiles = aConnection.getTiles();
        	  tIdx = connectedTiles.get(0)==t ? 1:0; // select the other tile
              if (current.getParent()==null  || connectedTiles.get(tIdx) != current.getParent().getTile())
            	  fringe.push(new Node(connectedTiles.get(tIdx), current, current.getDepth()+1));
          }
      }
      return new ArrayList<Tile>(possibleTiles);
  }

    
  public static void resetMap() {
    //I had problems with tests (Vincent)
    playersByNumber = new HashMap<Integer, Player>();
  }
}

class Tile {
  abstract;

  2 tiles -- 0..4 Connection connections; 
  Integer x;
  Integer y;
  Boolean hasBeenVisited = false;
  
  public abstract void land();
  
  public boolean isConnectedWith(Tile t) {
	  boolean isConnected = false;
	  for (Connection conn: getConnections()) {
		  if (conn.getTile(0)==t || conn.getTile(1)==t) {
			  isConnected = true;
			  break;
		  }
	  }
	  return isConnected;
  }
}

class ActionTile {
  isA Tile;

  immutable Integer inactivityPeriod;
  Integer turnsUntilActive= 0;
  
  
  InactivityStatus {
  	Active {
  		land / {
  			doLand();
  			setTurnsUntilActive(inactivityPeriod+1);
  		} -> Inactive;	
  	}
  	
  	Inactive {
  		inactivityPeriodCompleted -> Active;
  		land / {
  			doLandAsNormal();
  		} -> Inactive;
  	}
  }
  
  
  
  
  
  public void doLand(){

    Game currentGame = getGame();
    currentGame.addInactiveActionTile(this);
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
    setHasBeenVisited(true);

    Deck deck = currentGame.getDeck();
    ActionCard currentCard = deck.getCurrentCard();
    Game.Mode mode = currentCard.getActionCardMode();
    currentGame.setMode(mode);
  }
  
  public void doLandAsNormal() {
 	Game currentGame = this.getGame();
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
    
	currentGame.setNextPlayer();
   	currentGame.setMode(Game.Mode.GAME);
   	setHasBeenVisited(true);
  }
}

class NormalTile {
  isA Tile;
  
  public void land(){

    Game currentGame = this.getGame();
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
	
	currentGame.setNextPlayer();
    currentGame.setMode(Game.Mode.GAME);
    setHasBeenVisited(true);

  }
}

class WinTile {
  isA Tile;
  
  public void land(){
    /* Called when a player lands on the Win Tile */

    Game currentGame = getGame();
    this.setHasBeenVisited(true);
    currentGame.getCurrentPlayer().setCurrentTile(this);
    currentGame.setMode(Game.Mode.GAME_WON);

  }
}

class Connection {
}

class Deck {
  1 <@>- 0..32 ActionCard cards;
  1 -> 0..1 ActionCard currentCard;
  
  public void shuffle() {
    Random rand = new Random();
    for (int i=0; i<100; ++i){
        ActionCard card = getCard(0);
        addOrMoveCardAt(card, rand.nextInt(Game.NumberOfActionCards));
    }
    setCurrentCard(getCard(0));
  }
}

class ActionCard {
  abstract;
  immutable String instructions;
  public abstract Game.Mode getActionCardMode();
  
}

class RollDieActionCard {
  depend java.util.ArrayList;
  isA ActionCard;
  
  public ArrayList<Tile> play() {
	  return getDeck().getGame().rollDie();
  }
  public Game.Mode getActionCardMode(){
 
     return Game.Mode.GAME_ROLLDIEACTIONCARD;
   }
}

class ConnectTilesActionCard {
  isA ActionCard;
  
  public boolean play(Tile t1, Tile t2){
	return getDeck().getGame().connectTiles(t1, t2);
  }
  public Game.Mode getActionCardMode(){
 
     return Game.Mode.GAME_CONNECTTILESACTIONCARD;
   }
}

class RemoveConnectionActionCard {
  isA ActionCard;
  
  public boolean play(Tile t1, Tile t2) {
	  return getDeck().getGame().disconnectTiles(t1, t2);
  }
  public Game.Mode getActionCardMode(){
 
     return Game.Mode.GAME_REMOVECONNECTIONACTIONCARD;
   }
}

class TeleportActionCard {
  isA ActionCard;
  
  public void play(Tile t) {
	  t.land();
  }
  public Game.Mode getActionCardMode(){
 
     return Game.Mode.GAME_TELEPORTACTIONCARD;
   }
}

class LoseTurnActionCard {
  isA ActionCard;
  
  public Game.Mode getActionCardMode(){
 
     return Game.Mode.GAME_LOSETURNACTIONCARD;
   }
   
  public void play() {
  	Player currentPlayer = getDeck().getGame().getCurrentPlayer();
  	currentPlayer.loseTurn();
  }
}

class Die {
  depend java.util.Random;
  Random rand = new Random();
  public int roll() {
      return rand.nextInt(6)+1;
  }
}
