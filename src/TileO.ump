namespace ca.mcgill.ecse223.tileo.model;

use TileOPersistence.ump;
use TileOControllerStates.ump;
use ActionTileState.ump;
use PlayerState.ump;

class TileO {
  1 <@>- * Game games;
  1 -> 0..1 Game currentGame;
  
  public NormalTile addNormalTile(int x, int y, Game game){
    return new NormalTile(x, y, game);
  }
  public ActionTile addActionTile(int x, int y, Game game, int inactivtyPeriod){
    return new ActionTile(x, y, game, inactivtyPeriod);
  }
  public WinTile addWinTile(int x, int y, Game game){
    return new WinTile(x, y, game);
  }
  public boolean removeTile(Tile tile){
    boolean wasRemoved = false;

    //if(!this.equals(tile.getTileO))
    tile.delete();
    wasRemoved = true;

    return wasRemoved;
  }
}

class Game {
  depend ca.mcgill.ecse223.tileo.computer.StupidPlayer;
  depend ca.mcgill.ecse223.tileo.computer.GodPlayer;
  depend ca.mcgill.ecse223.tileo.computer.HackerPlayer;
  
  mode { DESIGN{} GAME{} GAME_WON{} GAME_ROLLDIEACTIONCARD{} GAME_CONNECTTILESACTIONCARD{} GAME_REMOVECONNECTIONACTIONCARD{} GAME_TELEPORTACTIONCARD{} GAME_LOSETURNACTIONCARD{} GAME_REMOVERANDOMTILEACTIONCARD{} GAME_TURNINACTIVEACTIONCARD{} }
  1 <@>- 2..4 Player players;
  1 <@>- * Tile tiles;
  1 <@>- * Connection connections;
  1 <@>- 1 Deck deck;
  1 <@>- 1 Die die;
  1 -> 0..1 Player currentPlayer;
  1 -> 0..1 WinTile winTile;
  1 -> * ActionTile inactiveActionTiles;
  const Integer SpareConnectionPieces = 32;
  Integer currentConnectionPieces;
  const Integer NumberOfActionCards = 32;
  lazy filename;
  public  String dieNumber;
  
  
  public void changeDie() {
    die = null;
    die = new Die(this);
  }
  
  public int getMaxSize() {
	  int max=0;
	  for (Tile aTile: tiles){
		  if (aTile.getX()>max)
			  max = aTile.getX();
		  if (aTile.getY()>max)
			  max = aTile.getY();
	  }
	  return max+1; // index starts at 0
  }
  
  public boolean connectTiles(Tile t1, Tile t2) {
	boolean wasAdded = false;
	int dx = t1.getX() - t2.getX();
  	int dy = t1.getY() - t2.getY();
  	
  	if (((dx==0&&(dy==1||dy==-1))||(dy==0&&(dx==1||dx==-1))) && t1!=t2 && t1!=null && t2!=null) {
  		Connection conn = new Connection(this);
  		conn.addTile(t1);
  		conn.addTile(t2);
  		wasAdded = true;
  	}
  	return wasAdded;
  }
  
  public boolean disconnectTiles(Tile t1, Tile t2) {
	Connection conn = null;
	boolean wasDeleted = false;
  	int dx = t1.getX() - t2.getX();
  	int dy = t1.getY() - t2.getY();
  	
  	if (((dx==0&&(dy==1||dy==-1))||(dy==0&&(dx==1||dx==-1))) && t1!=t2 && t1!=null && t2!=null) {
  		for (Connection c: t1.getConnections()){
  			if (t2 == c.getTile(0) || t2 == c.getTile(1)){
  				conn = c;
  				break;
  			}
  		}
  	}   	
  	if (conn!=null){
  		conn.delete();
  		wasDeleted = true;
  	}
  	return wasDeleted;
  }
  
  public ArrayList<Tile> rollDie() {
	int n = getDie().roll();
	dieNumber = Integer.toString(n);
  	ArrayList<Tile> possibleTiles = getCurrentPlayer().getPossibleMoves(n);
  	return possibleTiles;
  }
  
  public void setNextPlayer() {
  	while (true) {
  	  setCurrentPlayer(getPlayer((indexOfPlayer(getCurrentPlayer()) + 1)%numberOfPlayers()));
  	  if (getCurrentPlayer().getPlayerState()==Player.PlayerState.SkipTurn){
  	  	getCurrentPlayer().turnSkipped();
  	  }
  	  else break;
  	}
  	for (int i=0; i<inactiveActionTiles.size(); ++i) {
  		ActionTile t = inactiveActionTiles.get(i);
  		t.setTurnsUntilActive(t.getTurnsUntilActive()-1);
  		if (t.getTurnsUntilActive()==0) {
  			removeInactiveActionTile(t);
  			t.inactivityPeriodCompleted();
  			i--;
  		}
  	}
  }
  
  public void setNextCard() {
  	Deck currentDeck = getDeck();
  	ActionCard currentCard = currentDeck.getCurrentCard();
  	if (currentDeck.indexOfCard(currentCard)==currentDeck.numberOfCards()-1){
        currentDeck.shuffle();
        currentDeck.setCurrentCard(currentDeck.getCard(0));
    }
    else{
    	currentDeck.setCurrentCard(currentDeck.getCard(currentDeck.indexOfCard(currentCard)+1));
    }
  }
  
  public void swapPlayerForComputer(int playerNum, String type) {
    Player p = getPlayer(playerNum);
    Tile t = p.getStartingTile();
    p.forceDelete();
    // Add your type here, make sure to check your spelling

    if (type.equals("Stupid")) {
        StupidPlayer cp = new StupidPlayer(playerNum, this);
        System.out.println("Making player "+playerNum+" -> "+type);
        cp.setColor();
        cp.setStartingTile(t);
        addOrMovePlayerAt(cp, cp.getNumber());
    }
    else if (type.equals("God")) {
    	GodPlayer cp = new GodPlayer(playerNum, this);
    	System.out.println("Making player "+playerNum+" -> "+type);
    	cp.setColor();
    	cp.setStartingTile(t);
    	addOrMovePlayerAt(cp, cp.getNumber());
    }
    else if (type.equals("Hacker")) {
        HackerPlayer cp = new HackerPlayer(playerNum, this);
        System.out.println("Making player "+playerNum+" -> "+type);
        cp.setColor();
        cp.setStartingTile(t);
        addOrMovePlayerAt(cp, cp.getNumber());
    }
    else 
        throw new RuntimeException("Type not implemented");
    
  }

  public void swapComputerForPlayer(int compNum) {
    Player cp = getPlayer(compNum);
    Tile t = cp.getStartingTile();
    cp.forceDelete();
    Player p = new Player(compNum, this);
    p.setColor();
    p.setStartingTile(t);
    addOrMovePlayerAt(p, p.getNumber());
  }

  public void forceRemovePlayer(Player aPlayer) {
    players.remove(aPlayer);
  }

  public Tile getTileAtXY(int x, int y) {
    for (Tile t: getTiles()) {
        if (t.getX()==x && t.getY()==y)
            return t;
    }
    return null;
  }
  
  public void removeRandomTile(){
    Tile t;
    Random rand = new Random();
    ArrayList<Tile> tilesChecked = new ArrayList<Tile>();
    
    while (true) {
      boolean tileIsLegal = true;
      t = getTile(rand.nextInt(numberOfTiles()));
      
      if (tilesChecked.contains(t)) continue;
      else tilesChecked.add(t);
      
      // checks
      if (t instanceof WinTile) tileIsLegal = false;
      else {
    	  for (Player p: getPlayers()) {
            if (p.getStartingTile() == t || p.getCurrentTile() == t) {
              tileIsLegal = false;
              break;
            }
    	  }
      }
      if (tileIsLegal) break;
      if (tilesChecked.size() == numberOfTiles()) return; // there's no tile to remove
    }
    t.delete();
  }
}

class Player {
  depend ca.mcgill.ecse223.tileo.util.Node;
	
  color { RED{} BLUE{} GREEN{} YELLOW{} }
  1 -> 0..1 Tile startingTile;
  0..4 -> 0..1 Tile currentTile;
  unique Integer number;
  Integer turnsUntilActive = 0;  
  
  public ArrayList<Tile> getPossibleMoves(int depth){
      // Depth first search with limited depth, Iterate over the possible children
      // Cannot go back but loops are allowed
      Stack<Node> fringe = new Stack<Node>();
      List<Connection> connections;
      List<Tile> connectedTiles;
      HashSet<Tile> possibleTiles = new HashSet<Tile>();
      int tIdx;
      Tile t;
      
      Node current = new Node(currentTile, null, 0);
      fringe.push(current);

      while (!fringe.isEmpty()) {
          current = fringe.pop();
    	  t = current.getTile();
    	  
          if (current.getDepth() == depth){
        	  possibleTiles.add(t);
              continue;
          }
          
          connections = t.getConnections();
          for (Connection aConnection : connections){
        	  connectedTiles = aConnection.getTiles();
        	  tIdx = connectedTiles.get(0)==t ? 1:0; // select the other tile
              if (current.getParent()==null  || connectedTiles.get(tIdx) != current.getParent().getTile())
            	  fringe.push(new Node(connectedTiles.get(tIdx), current, current.getDepth()+1));
          }
      }
      return new ArrayList<Tile>(possibleTiles);
  }

    
  public static void resetMap() {
    //I had problems with tests (Vincent)
    playersByNumber = new HashMap<Integer, Player>();
  }
  
  public void forceDelete() {
    playersByNumber.remove(getNumber());
    startingTile = null;
    currentTile = null;
    Game placeholderGame = game;
    this.game = null;
    placeholderGame.forceRemovePlayer(this);
  }
}

class Tile {
  abstract;

  2 tiles -- 0..4 Connection connections; 
  Integer x;
  Integer y;
  Boolean hasBeenVisited = false;
  
  public abstract void land();
  
  public boolean isConnectedWith(Tile t) {
	  boolean isConnected = false;
	  for (Connection conn: getConnections()) {
		  if (conn.getTile(0)==t || conn.getTile(1)==t) {
			  isConnected = true;
			  break;
		  }
	  }
	  return isConnected;
  }
  
  public ArrayList<Tile> getDisconnectedNeighbors() {
    ArrayList<Tile> neigbors = new ArrayList<Tile>();
    Tile t;
    int nx;
    int ny;

    //up
    nx = getX();
    ny = getY()-1;
    if (ny > 0) {
        t = getGame().getTileAtXY(nx,ny);
        if (t!=null)
            if (!isConnectedWith(t))
                neigbors.add(t);
    }
    //down
    nx = getX();
    ny = getY()+1;
    t = getGame().getTileAtXY(nx,ny);
    if (t!=null)
        if (!isConnectedWith(t))
            neigbors.add(t);
    //left
    nx = getX()-1;
    ny = getY();
    if (nx > 0) {
        t = getGame().getTileAtXY(nx,ny);
        if (t!=null)
            if (!isConnectedWith(t))
                neigbors.add(t);
    }
    //right
    nx = getX()+1;
    ny = getY();
    t = getGame().getTileAtXY(nx,ny);
    if (t!=null)
        if (!isConnectedWith(t))
            neigbors.add(t);

    return neigbors;
  }
  
  public ArrayList<Tile> getNeighbours(int boardsize){

    ArrayList<Tile> neigbours = new ArrayList<Tile>();

    if(!(this.getX() == boardsize )) {
      if (game.getTileAtXY(this.getX() + 1, this.getY()) != null)
        neigbours.add(game.getTileAtXY(this.getX() + 1, this.getY()));
    }

    if(!(this.getX() == 0)) {
      if (game.getTileAtXY(this.getX() - 1, this.getY()) != null)
        neigbours.add(game.getTileAtXY(this.getX() - 1, this.getY()));
    }

    if(!(this.getY() == boardsize)) {
      if (game.getTileAtXY(this.getX(), this.getY() - 1) != null)
        neigbours.add(game.getTileAtXY(this.getX(), this.getY() - 1));
    }

    if(!(this.getY() == 0)) {
      if (game.getTileAtXY(this.getX(), this.getY() + 1) != null)
        neigbours.add(game.getTileAtXY(this.getX(), this.getY() + 1));
    }


    return neigbours;
  }
}

class ActionTile {
  isA Tile;

  immutable Integer inactivityPeriod;
  Integer turnsUntilActive= 0;
    
  public void doLand(){
    Game currentGame = getGame();
    currentGame.addInactiveActionTile(this);
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
    setHasBeenVisited(true);

    Deck deck = currentGame.getDeck();
    ActionCard currentCard = deck.getCurrentCard();
    Game.Mode mode = currentCard.getActionCardMode();
    currentGame.setMode(mode);
  }
  
  public void doLandAsNormal() {
 	Game currentGame = this.getGame();
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
    
	currentGame.setNextPlayer();
   	currentGame.setMode(Game.Mode.GAME);
   	setHasBeenVisited(true);
  }
}

class NormalTile {
  isA Tile;
  
  public void land(){

    Game currentGame = this.getGame();
    Player currentPlayer = currentGame.getCurrentPlayer();
    currentPlayer.setCurrentTile(this);
	
	currentGame.setNextPlayer();
    currentGame.setMode(Game.Mode.GAME);
    setHasBeenVisited(true);

  }
}

class WinTile {
  isA Tile;
  
  public void land(){
    /* Called when a player lands on the Win Tile */

    Game currentGame = getGame();
    this.setHasBeenVisited(true);
    currentGame.getCurrentPlayer().setCurrentTile(this);
    currentGame.setMode(Game.Mode.GAME_WON);

  }
}

class Connection {
}

class Deck {
  1 <@>- 0..32 ActionCard cards;
  1 -> 0..1 ActionCard currentCard;
  
  1 -> * ConnectTilesActionCard;
  1 -> * LoseTurnActionCard;
  1 -> * RemoveConnectionActionCard;
  1 -> * RemoveRandomTileActionCard;
  1 -> * RollDieActionCard;
  1 -> * TeleportActionCard;
  1 -> * TurnInactiveActionCard;
  
  public void shuffle() {
    Random rand = new Random();
    for (int i=0; i<100; ++i){
        ActionCard card = getCard(0);
        addOrMoveCardAt(card, rand.nextInt(Game.NumberOfActionCards));
    }
    setCurrentCard(getCard(0));
  }
  
  public void print() {
    System.out.println("~~~ DECK ~~~~");
    System.out.println("RollDieActionCard: "+numberOfCardsForType(0));
    System.out.println("ConnectTilesActionCard: "+numberOfCardsForType(1));
    System.out.println("RemoveConnectionActionCard: "+numberOfCardsForType(2));
    System.out.println("TeleportActionCard: "+numberOfCardsForType(3));
    System.out.println("LoseTurnActionCard: "+numberOfCardsForType(4));
    System.out.println("RemoveRandomTileActionCard: "+numberOfCardsForType(5));
    System.out.println("TurnInactiveActionCard: "+numberOfCardsForType(6));
    System.out.println("");
  }

   public int numberOfCardsForType(int type){
    	switch (type) {
	   		case 0:
	   			return numberOfRollDieActionCards();
	   		case 1:
	   			return numberOfConnectTilesActionCards();
	   		case 2:
	   			return numberOfRemoveConnectionActionCards();
	   		case 3:
	   			return numberOfTeleportActionCards();
	   		case 4:
	   			return numberOfLoseTurnActionCards();
	   		case 5:
	   			return numberOfRemoveRandomTileActionCards();
	   		case 6:
	   			return numberOfTurnInactiveActionCards();
	   		default:
	   			throw new RuntimeException("Card type not supported");
     }
  }

   public void addCards(int n, int cardType){
	n = n%maximumNumberOfCards();
	if (numberOfCards() + n > maximumNumberOfCards()) n = maximumNumberOfCards() - n;
    switch (cardType) {
	        case 0:
	            // ROLL
	            for (int i=0; i<n; ++i)
	                addRollDieActionCard(new RollDieActionCard("Roll the die for an extra turn", this));
	            break;
	        case 1:
	            // CONN
	    		for (int i=0;i<n;++i)
	                addConnectTilesActionCard(new ConnectTilesActionCard("Connect two tiles", this));
	            break;
	        case 2:
	            // RMCONN
	    		for (int i=0;i<n;++i)
	    		    addRemoveConnectionActionCard(new RemoveConnectionActionCard("Remove a connection", this));
	            break;
	        case 3:
	            // TELE
	    		for (int i=0;i<n;++i)
	    		    addTeleportActionCard(new TeleportActionCard("Move your piece to a new tile", this));
	            break;
	        case 4:
	            // LOSE
	    		for (int i=0;i<n;++i)
	    		    addLoseTurnActionCard(new LoseTurnActionCard("Lose your next turn", this));
	            break;
	        case 5:
	            // RMRANDOM
	    		for (int i=0;i<n;++i)
	    		    addRemoveRandomTileActionCard(new RemoveRandomTileActionCard("Remove a random tile", this));
	            break;
	        case 6:
	            // TURNINACTIVE
	    		for (int i=0;i<n;++i)
	    		    addTurnInactiveActionCard(new TurnInactiveActionCard("Remove a random tile", this));
	            break;
	        default:
	        	throw new RuntimeException("Card type not implemented");
	    }
  }

   public void rmCards(int toRm, int cardType){
	   ActionCard c;
	   for (int i=0; i<toRm; ++i) {	
		   switch (cardType) {
		   		case 0:
		   			c = getRollDieActionCard(0);
		   			removeRollDieActionCard((RollDieActionCard)c);
		   			c.delete();
		   			break;
		   		case 1:
		   			c = getConnectTilesActionCard(0);
		   			removeConnectTilesActionCard((ConnectTilesActionCard)c);
		   			c.delete();
		   			break;
		   		case 2:
		   			c = getRemoveConnectionActionCard(0);
		   			removeRemoveConnectionActionCard((RemoveConnectionActionCard)c);
		   			c.delete();
		   			break;
		   		case 3:
		   			c = getTeleportActionCard(0);
		   			removeTeleportActionCard((TeleportActionCard)c);
		   			c.delete();
		   			break;
		   		case 4:
		   			c = getLoseTurnActionCard(0);
		   			removeLoseTurnActionCard((LoseTurnActionCard)c);
		   			c.delete();
		   			break;
		   		case 5:
		   			c = getRemoveRandomTileActionCard(0);
		   			removeRemoveRandomTileActionCard((RemoveRandomTileActionCard)c);
		   			c.delete();
		   			break;
		   		case 6:
		   			c = getTurnInactiveActionCard(0);
		   			removeTurnInactiveActionCard((TurnInactiveActionCard)c);
		   			c.delete();
		   			break;
		   		default:
		   			throw new RuntimeException("Card type not supported");
		   	}
	   }
	}
}

class ActionCard {
  abstract;
  immutable String instructions;
  public abstract Game.Mode getActionCardMode();
  
}

class RollDieActionCard {
  depend java.util.ArrayList;
  isA ActionCard;
  
  public ArrayList<Tile> play() {
	  return getDeck().getGame().rollDie();
  }
  public Game.Mode getActionCardMode(){
     return Game.Mode.GAME_ROLLDIEACTIONCARD;
   }
}

class ConnectTilesActionCard {
  isA ActionCard;
  
  public boolean play(Tile t1, Tile t2){
	return getDeck().getGame().connectTiles(t1, t2);
  }
  public Game.Mode getActionCardMode(){ 
     return Game.Mode.GAME_CONNECTTILESACTIONCARD;
   }
}

class RemoveConnectionActionCard {
  isA ActionCard;
  
  public boolean play(Tile t1, Tile t2) {
	  return getDeck().getGame().disconnectTiles(t1, t2);
  }
  public Game.Mode getActionCardMode(){
     return Game.Mode.GAME_REMOVECONNECTIONACTIONCARD;
   }
}

class TeleportActionCard {
  isA ActionCard;
  
  public void play(Tile t) {
	  t.land();
  }
  public Game.Mode getActionCardMode(){ 
     return Game.Mode.GAME_TELEPORTACTIONCARD;
   }
}

class LoseTurnActionCard {
  isA ActionCard;
  
  public Game.Mode getActionCardMode(){ 
     return Game.Mode.GAME_LOSETURNACTIONCARD;
   }
   
  public void play() {
  	Player currentPlayer = getDeck().getGame().getCurrentPlayer();
  	currentPlayer.loseTurn();
  }
}

class RemoveRandomTileActionCard {
    isA ActionCard;
    
    public Game.Mode getActionCardMode() {
      return Game.Mode.GAME_REMOVERANDOMTILEACTIONCARD;
    }
    
    public void play() {
      getDeck().getGame().removeRandomTile();
    }
}


 class TurnInactiveActionCard {
 	isA ActionCard;
 	
 	public Game.Mode getActionCardMode() {
 		return Game.Mode.GAME_TURNINACTIVEACTIONCARD;
 	}
 }

class Die {
  depend java.util.Random;
  Random rand = new Random();
  public int roll() {
      return rand.nextInt(6)+1;
  }
}
